import http
import co
import fmt
import process
import time
import syscall
import fs
import io
import strings
import os
import path
import json

var seed = time.unix() as u64

var nature_path = '/usr/local/nature/bin/nature'

fn random_u32(rawptr<u64> state):u32 {
    *state ^= *state >> 12
    *state ^= *state << 25
    *state ^= *state >> 27
    return ((*state * 0x2545F4914F6CDD1D) >> 32) as u32
}

fn create_tempdir():string! {
    // rand u32
    var suffix = random_u32(&seed)
    // println('suffix:', suffix)
    var tmpdir_path = fmt.sprintf('/tmp/playgrounds-%d', suffix)
    syscall.mkdir(tmpdir_path, 0755)

    return tmpdir_path
}


fn playgrounds_run(string code):string! {
    // create temp dir
    var tmpdir_path = create_tempdir()

    // write code to temp file main.n
    var source_path = fmt.sprintf('%s/main.n', tmpdir_path)
    var f = fs.open(source_path, syscall.O_WRONLY | syscall.O_CREAT, 0755)
    f.write(code as [u8])

    var exec_path = fmt.sprintf('%s/main', tmpdir_path)

    println('build exec_path: ', exec_path)

    // process run 'nature build -o main main.n'
    var state = process.run(nature_path, ['build','--target', 'linux_amd64','-o', exec_path, source_path]) catch e {
        throw errorf('nature build failed: %s', nature_path, source_path, e.msg())
    }

    f.close()
    if state.exit_code != 0 {
        return fmt.sprintf(state.stderr)
    }
    println('build success')

    // process run exec file main get output
    // docker run --rm -v /root/main:/app/main:ro alpine:latest /app/main
    var mount_arg = fmt.sprintf('%s:/app/main:ro', exec_path)

    var timeout_duration = "10" // s
    var cmd = process.command('timeout', [timeout_duration, 'docker', 'run', '--rm', '-v', mount_arg, 'alpine:3.18', '/app/main']) catch e {
        println('catch error', e.msg())
        throw errorf('docker command create failed: %s', e.msg())
    }

    var output_buf = new io.buffer()

    cmd.stdout = output_buf
    cmd.stderr = output_buf
    var p = cmd.spawn()
    p.wait() catch e {
        println('cmd.spawn catch error', e.msg())
        throw errorf('exec failed: %s', e.msg())
    }

    println('docker exec success')

    os.rmdir(tmpdir_path, true)
    println('exit code: ', p.exit_code)

    if p.exit_code != 0 {
        throw errorf('exit code: %d', p.exit_code)
    }

    var output = output_buf.read_all() as string
    return output
}

fn main():void! {
    var app = http.server()

    app.get('/hello', fn(http.request_t req, ptr<http.response_t> res):void! {
        res.send('hello world')
    })

    app.post('/api/playgrounds/run', fn(http.request_t req, ptr<http.response_t> res):void! {
        var body = req.body

        res.headers['Content-Type'] = 'application/json'
        res.headers['Access-Control-Allow-Origin'] = '*'

        var result = playgrounds_run(body) catch e {
            println('catch error', e.msg())
            res.status = 500 // 500 Internal Server Error
            res.send(fmt.sprintf('{"error": "%s"}', e.msg()))
            return
        }

        // result = 'hello world\n';
        println('read body', body, 'result', result)

        res.send(json.serialize({'data': result}))
    })

    println('server started: 8888')
    app.listen(8888)
    println('server is closed')
}
